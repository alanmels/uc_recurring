<?php
// $Id$

/**
 * @file
 * Provides hosted gateway specific code for recurring payments, specifically
 * Authorize.net ARB and Paypal WPS
 */

/******************************************************************************
 * DRUPAL HOOKS
 *****************************************************************************/

/**
 * Implementation of hook_menu().
 */
function uc_recurring_hosted_menu() {
  $items['uc_recurring_hosted/paypal/ipn/%'] = array( 
    'title' => 'PayPal IPN',
    'page callback' => 'uc_recurring_hosted_paypal_ipn',
    'access callback' => 'uc_paypal_ipn_access',
    'type' => MENU_CALLBACK,
  );

  // this menu item is a mock url for emulating the paypal IPN
  $items['uc_recurring_hosted/paypal/cgi-bin/webscr'] = array(
    'title' => 'PayPal Website',
    'page callback' => '_uc_recurring_hosted_paypal_mock_web_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/******************************************************************************
 * UBERCART HOOKS (including uc_recurring)
 *****************************************************************************/

/**
 * Implementation of hook_recurring_info().
 */
function uc_recurring_hosted_recurring_info() {
  // *************************************
  // AUTHORIZE.NET ARB
  // ************************************
  $items['authorizenet_arb'] = array(
    'name' => t('Authorize.net (ARB)'),
    'payment method' => 'credit',
    'module' => 'uc_recurring_hosted',
    'fee handler' => 'authorizenet_arb',
    'process callback' => 'uc_recurring_hosted_authorizenet_arb_process',
    'renew callback' => 'uc_recurring_hosted_authorizenet_arb_renew',
    'cancel callback' => 'uc_recurring_hosted_authorizenet_arb_cancel',
    'menu' => array(
      'update' => array(
        'title' => 'Update Account Details',
        'page arguments' => array('uc_recurring_hosted_authorizenet_arb_update_form'),
      ),
      'cancel' => UC_RECURRING_MENU_DEFAULT,
    ),
    'own handler' => TRUE,
  );

  if (variable_get('uc_authnet_arb_mode', 'disabled') != 'disabled') {
    $items['authorizenet'] = $items['authorizenet_arb'];
  }

  // *************************************
  // PAYPAL WPS
  // ************************************
  if (module_exists('uc_paypal')) {
    $items['paypal_wps'] = array(
      'name' => t('Paypal website payments standard'),
      'payment method' => 'paypal_wps',
      'fee handler' => 'paypal_wps',
      'module' => 'uc_recurring_hosted',
      'process callback' => 'uc_recurring_hosted_wps_process',
      'own_hander' => TRUE,
      'menu' => array(
        'cancel' => array(
          'title' => 'Cancel', 
          'page arguments' => array('uc_recurring_hosted_cancel_form'),
        ),
      ),
    );
  }

  return $items;
}

/******************************************************************************
 * AUTHORIZE.NET ARB
 *****************************************************************************/

/**
 * Set up the recurring fee using the ARB api.
 *
 * @param $order
 *   The order object.
 * @param $fee
 *   The fee object.
 * @return
 *   TRUE if recurring fee setup
 */
function uc_recurring_hosted_authorizenet_arb_process($order, &$fee) {
  $fee->fee_handler = 'authorizenet_arb';
  // We can't just call the existing arb function in ubercart as that would try
  // and setup thing that uc_recurring does now for all recurring fees.
  // return uc_authorizenet_arb_create($order, $fee);
  $server = variable_get('uc_authnet_arb_mode', 'disabled');

  // Setup variables for the payment schedule.
  list($length, $unit) = explode(' ', $fee->regular_interval);
  list($trial_length, $trial_unit) = explode(' ', $fee->initial_charge);

  // Convert weeks and years to days.
  if ($unit == 'weeks') {
    $length *= 7;
    $unit = 'days';
  }
  elseif ($unit == 'years') {
    $length *= 365;
    $unit = 'days';
  }

  // Make sure we have valid values for Authorize.Net.
  if ($length <= 0 || $unit == 'days' && $length > 365 || $unit == 'months' && $length > 12) {
    watchdog('uc_authorizenet', 'Product @sku has invalid interval settings for Authorize.Net - @length @unit', array('@sku' => $fee->title, '@length' => $length, '@unit' => $unit), WATCHDOG_ERROR);
    return FALSE;
  }

  // Get the country data for the billing and shipping information.
  $billing_country = uc_get_country_data(array('country_id' => $order->billing_country));
  $delivery_country = uc_get_country_data(array('country_id' => $order->delivery_country));

  // Build the data array for the request.
  $data = array(
    'refId' => substr($order->order_id .'-'. time(), 0, 20),
    'subscription' => array(
      'name' => substr(t('Order @order_id', array('@order_id' => $order->order_id)), 0, 50),
      'paymentSchedule' => array(
        'interval' => array(
          'length' => $length,
          'unit' => $unit,
        ),
        'startDate' => date('Y-m-d', $fee->next_charge),
        'totalOccurrences' => $fee->remaining_intervals == -1 ? 9999 : $fee->remaining_intervals,
        'trialOccurrences' => '0',
      ),
      'amount' => round($fee->fee_amount, 2),
      'trialAmount' => 0,
      'payment' => array(), // Data inserted below based on payment method.
      'order' => array(
        'invoiceNumber' => substr($order->order_id, 0, 20),
        'description' => substr(t('Order @order_id - @sku', array('@order_id' => $order->order_id, '@sku' => $fee->model)), 0, 255),
      ),
      'customer' => array(
        'id' => substr($order->uid, 0, 20),
        'email' => substr($order->primary_email, 0, 255),
        'phoneNumber' => substr($order->billing_phone, 0, 25),
      ),
      'billTo' => array(
        'firstName' => substr($order->billing_first_name, 0, 50),
        'lastName' => substr($order->billing_last_name, 0, 50),
        'company' => substr($order->billing_company, 0, 50),
        'address' => substr($order->billing_street1, 0, 60),
        'city' => substr($order->billing_city, 0, 40),
        'state' => substr(uc_get_zone_code($order->billing_zone), 0, 2),
        'zip' => substr($order->billing_postal_code, 0, 20),
        'country' => !$billing_country ? '' : $billing_country[0]['country_iso_code_2'],
      ),
      'shipTo' => array(
        'firstName' => substr($order->delivery_first_name, 0, 50),
        'lastName' => substr($order->delivery_last_name, 0, 50),
        'company' => substr($order->delivery_company, 0, 50),
        'address' => substr($order->delivery_street1, 0, 60),
        'city' => substr($order->delivery_city, 0, 40),
        'state' => substr(uc_get_zone_code($order->delivery_zone), 0, 2),
        'zip' => substr($order->delivery_postal_code, 0, 20),
        'country' => !$delivery_country ? '' : $delivery_country[0]['country_iso_code_2'],
      ),
    ),
  );

  // Strip out the shipping info if it isn't necessary.
  if (empty($data['subscription']['shipTo']['firstName'])) {
    unset($data['subscription']['shipTo']);
  }

  // Add the payment information to the data array based on the payment method.
  if ($order->payment_method == 'credit') {
    if ($order->payment_details['cc_exp_month'] < 10) {
      $order->payment_details['cc_exp_month'] = '0'. $order->payment_details['cc_exp_month'];
    }

    $data['subscription']['payment'] = array(
      'creditCard' => array(
        'cardNumber' => $order->payment_details['cc_number'],
        'expirationDate' => $order->payment_details['cc_exp_year'] .'-'. $order->payment_details['cc_exp_month'],
      ),
    );
  }
 
  // Build the XML string.
  $xml = _uc_authorizenet_xml_api_wrapper('ARBCreateSubscriptionRequest', _uc_authorizenet_array_to_xml($data));

  // Send the request off to the server and get the response.
  $response = uc_authorizenet_xml_api($server, $xml);

  // Fail if the response is empty or FALSE.
  if (!$response) {
    return FALSE;
  }

  // Parse the response into a data array.
  $data = _uc_authorizenet_arb_parse_response($response);

  if ($data['resultCode'] == 'Error') {
    uc_order_comment_save($order->order_id, 0, t('Authorize.Net: Recurring fee for @model failed.<br />@error - @text', array('@model' => $fee->model, '@error' => $data['code'], '@text' => $data['text'])), 'admin');
    return FALSE;
  }
  uc_order_comment_save($order->order_id, 0, t('Authorize.Net: ARB subscription created - @id', array('@id' => $data['subscriptionId'])));
  
  // Save the new credit reference to the db.
  $record = array(
    'rfid' => $fee->rfid, 
    'subscription_id' => $data['subscriptionId'],
  );
  drupal_write_record('uc_recurring_hosted', $record);
  $order->data = uc_credit_log_reference($order->order_id, $data['subscriptionId'], $order->payment_details['cc_number']);

  return TRUE;
}

/**
 * Recurring fee renew callback for Authorize.net ARB.
 *
 * @param $order
 *   The reneal order object.
 * @param $fee
 *   The recurring fee object.
 * 
 * @return
 *   Always returns TRUE.
 */
function uc_recurring_hosted_authorizenet_arb_renew($order, $fee) {
  uc_payment_enter($order->order_id, $order->payment_menthd, $_POST['x_amount'], $fee->uid, NULL, t('Authorize.net ARB subsription ID: @subscription_id', array('@subscription_id' => $_POST['x_subscription_id'])));

  return TRUE;
}

/**
 * Implementation of hook_uc_auth_arb_payment().
 * Called during an ARB silent post. 
 */
function uc_recurring_hosted_uc_auth_arb_payment($post) {
  $fee = db_fetch_object(db_query("SELECT rfid FROM {uc_recurring_hosted} WHERE subscription_id = '%s'", $post['x_subscription_id']));

  if (!empty($fee)) {
    $fee = uc_recurring_fee_user_load($fee->rfid);
    uc_recurring_renew($fee);

    // Log the ARB payment if enabled.
    if (variable_get('uc_authnet_report_arb_post', FALSE)) {
      watchdog('uc_authorizenet', 'ARB payment reported for order @order_id: <pre>@post</pre>', array('@order_id' => $fee->order_id, '@post' => print_r($post, TRUE)));
    }
  }
}

/**
 * Cancel the recurring fee using the ARB api.
 *
 * @param $order
 *   The order object.
 * @param $fee
 *   The fee object.
 * @return
 *   TRUE if recurring fee was cancelled.
 */
function uc_recurring_hosted_authorizenet_arb_cancel($order, &$fee) {
  $server = variable_get('uc_authnet_arb_mode', 'disabled');
  
  $order = uc_order_load($order->order_id);
  $subscription_id = end(array_keys($order->data['cc_txns']['references']));

  // Build the data array for the request.
  $data = array(
    'refId' => substr($order->order_id .'-'. time(), 0, 20),
    'subscriptionId' => $subscription_id,
  );

  // Build the XML string.
  $xml = _uc_authorizenet_xml_api_wrapper('ARBCancelSubscriptionRequest', _uc_authorizenet_array_to_xml($data));

  // Send the request off to the server and get the response.
  $response = uc_authorizenet_xml_api($server, $xml);

  // Fail if the response is empty or FALSE.
  if (!$response) {
    return FALSE;
  }

  // Parse the response into a data array.
  $data = _uc_authorizenet_arb_parse_response($response);

  if ($data['resultCode'] == 'Error') {
    if (!empty($order_id)) {
      uc_order_comment_save($order_id, 0, t('Authorize.Net: Subscription @subscription_id cancellation failed.<br />@error - @text', array('@subscription_id' => $subscription_id, '@error' => $data['code'], '@text' => $data['text'])), 'admin');
    }
    return FALSE;
  }

  uc_order_comment_save($order_id, 0, t('Authorize.Net: Subscription @subscription_id cancelled.', array('@subscription_id' => $subscription_id)), 'admin');

  return TRUE;
}

/**
 * Create form for updating credit card details for recurring fee.
 */
function uc_recurring_hosted_authorizenet_arb_update_form($form_state, $rfid) {
  $form['rfid'] = array(
    '#type' => 'value',
    '#value' => $rfid,
  );
  $form['cc_data'] = array(
    '#type' => 'fieldset',
    '#title' => t('Credit card details'),
    '#theme' => 'uc_payment_method_credit_form',
    '#tree' => TRUE,
  );
  $form['cc_data'] += uc_payment_method_credit_form(array(), $order);
  unset($form['cc_data']['cc_policy']);

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update'),
    '#suffix' => l(t('Cancel'), 'user/'. $user->uid),
  );

  return $form;
}

/**
 * Implements update form submit for the authorizenet ARB gateway.
 */
function uc_recurring_hosted_authorizenet_arb_update_form_submit(&$form, &$form_state) {
  $fee = uc_recurring_fee_user_load($form_state['values']['rfid']);
  $order = uc_order_load($fee->order_id);
  $order->payment_details = $form_state['values']['cc_data'];
  $subscription_id = end(array_keys($order->data['cc_txns']['references']));
    
  if ($order->payment_details['cc_exp_month'] < 10) {
    $order->payment_details['cc_exp_month'] = '0'. $order->payment_details['cc_exp_month'];
  }

  // Build the data array for the request.
  $updates = array(
    'payment' => array(
      'creditCard' => array(
        'cardNumber' => $order->payment_details['cc_number'],
        'expirationDate' => $order->payment_details['cc_exp_year'] .'-'. $order->payment_details['cc_exp_month'],
      ),
    ),
  );
  
  if (uc_authorizenet_arb_update($subscription_id, $updates, $order->order_id)) {
    drupal_set_message(t('Account updated.'));
    $form_state['redirect'] = 'user/'. $form_state['values']['uid'];
  }
  else {
    drupal_set_message(t('Account update failed.'), 'error');
  }
}


/******************************************************************************
 * PAYPAL WPS
 *****************************************************************************/

/**
 * Create the recurring fee.
 */
function uc_recurring_hosted_paypal_wps_process($order, &$fee) {
  // the recurring payment is setup at the time of product purchase
  $subscr_id = check_plain($_POST['subscr_id']);
  if ($subscr_id) {
    $fee->data['subscr_id'] = $subscr_id;
    return TRUE;
  }
  return FALSE;
}

/**
 * Paypal website payments standard process
 *
 * Normally in a payment gateway we would just need to define the callback 'process':
 * e.g. function uc_recurring_hosted_wps_process($order, $fee)
 *
 * But paypal_wps is implemented by altering the checkout review form to 
 * change the form so it is submitted directly to paypal, we are using this
 * same trick to alter the paypal form, its a messy hack but works for now.
 */
function uc_recurring_hosted_form_uc_paypal_wps_form_alter(&$form, $form_state) {
  $order = $form['#parameters'][2];
 
  // if recurring fees exist in the order
  $recurring_fees = uc_recurring_get_recurring_products_in_order($order);

  if (count($recurring_fees) > 0) {
    // TODO: what do we do if someone tries to order more then one subscription??
    // we will just process the first for now
    $recurring_fee = $recurring_fees[0]; 
    if (count($recurring_fees) > 1) {
      drupal_set_message(t('Sorry recurring payments can only be setup for one product at a time when paying via paypal, only the first recurring payment will be setup when you click on Submit order.'), 'warning');
    }

    // IPN control notify URL
    $data['notify_url'] = url('uc_recurring_hosted/paypal/ipn/'. $order->order_id, array('absolute' => TRUE));

    $data['cmd'] = '_xclick-subscriptions';  
    $data['item_name'] = t('Order @order_id at !store', array('@order_id' => $order->order_id, '!store' => variable_get('uc_store_name', url('<front>', array('absolute' => TRUE)))));
    // first payment
    list($p, $t) = explode(' ', $recurring_fee['recurring product']->initial_charge);
    $data['a1'] = sprintf("%0.2f", $order->order_total);
    $data['p1'] = $p;  
    $data['t1'] = strtoupper($t[0]); 
    // recurring payments
    list($p, $t) = explode(' ', $recurring_fee['recurring product']->regular_interval);
    $data['a3'] = sprintf("%0.2f", $product_fee->fee_amount == 0 ? $recurring_fee['product']->price : $recurring_fee['recurring product']->fee_amount);
    $data['p3'] = $p;  
    $data['t3'] = strtoupper($t[0]);
    
    $data['src'] = 1;
    if ($recurring_fee['recurring product']->number_intervals > 0) {
      $data['srt'] = $recurring_fee['recurring product']->number_intervals;
    }
    $data['sra'] = 1; // reattempt failed payments

    foreach ($data as $name => $value) {
      if (!empty($value)) {
        $form[$name] = array('#type' => 'hidden', '#value' => $value);
      }
    }
  }
}

/**
 * Handle IPN callbacks for recurring payments
 */
function uc_recurring_hosted_paypal_ipn($order_id) {
  watchdog('uc_recurring_hosted', 'Receiving IPN at URL for order @order_id. @debug',
    array('@order_id' => $order_id, '@debug' => variable_get('uc_paypal_wps_debug_ipn', FALSE) ? '<pre>'. print_r($_POST, TRUE) .'</pre>' : ''));

  if (!isset($_POST['invoice'])) {
    watchdog('uc_recurring_hosted', 'IPN attempted with invalid order ID.', array(), WATCHDOG_ERROR);
    return;
  }

  if (($len = strpos($_POST['invoice'], '-')) > 0) {
    $order_id = intval(substr($_POST['invoice'], 0, $len));
  }
  else {
    $order_id = intval($_POST['invoice']);
  }

  $order = uc_order_load($order_id);

  if ($order == FALSE) {
    watchdog('uc_recurring_hosted', 'IPN attempted for non-existent order.', array(), WATCHDOG_ERROR);
    return;
  }

  // Assign posted variables to local variables
  $payment_status = check_plain($_POST['payment_status']);
  $payment_amount = check_plain($_POST['mc_gross']);
  $payment_currency = check_plain($_POST['mc_currency']);
  $payment_fee = check_plain($_POST['mc_fee']);
  $receiver_email = check_plain($_POST['receiver_email']);
  $txn_id = check_plain($_POST['txn_id']);
  $txn_type = check_plain($_POST['txn_type']);
  $payer_email = check_plain($_POST['payer_email']);

  $req = '';
 
  if ($order == FALSE) {
    watchdog('uc_recurring_hosted', 'IPN attempted for non-existent order.', array(), WATCHDOG_ERROR);
    return;
  }

  foreach ($_POST as $key => $value) {
    $value = urlencode(stripslashes($value));
    $req .= $key .'='. $value .'&';
  }

  $req .= 'cmd=_notify-validate';

  if (variable_get('uc_paypal_wpp_server', '') == 'https://api-3t.paypal.com/nvp') {
    $host = 'https://www.paypal.com/cgi-bin/webscr';
  }
  else {
    $host = variable_get('uc_paypal_wps_server', 'https://www.sandbox.paypal.com/cgi-bin/webscr');
  }

  $response = drupal_http_request($host, array(), 'POST', $req);

  // TODO: Change this to property_exists when we have a PHP requirement >= 5.1.
  if (array_key_exists('error', $response)) {
    watchdog('uc_recurring_hosted', 'IPN failed with HTTP error @error, code @code.', array('@error' => $response->error, '@code' => $response->code), WATCHDOG_ERROR);
    return;
  }

  if (strcmp($response->data, 'VERIFIED') == 0) {
    watchdog('uc_recurring_hosted', 'IPN transaction verified.');

    // subscription
    $subscr_id = check_plain($_POST['subscr_id']);

    switch ($txn_type) {
      case 'subscr_signup':
        // first we need to setup the recurring fee, since paypal_wps overrides the submit order function we need to call uc_recurring_order submit function here
        uc_recurring_order('submit', $order, NULL);
        $txn_id = $subscr_id; // subscriptions do not have a txn_id, so we will record the subscr_id instead
        break;
      case 'subscr_payment':
        if ($order->order_status == 'completed') {
          // Fetch fee from database.
          $fees = uc_recurring_get_fees($order);
          if ($fee = $fees[0]) {
            $order_id = uc_recurring_renew($fee);
            $order = uc_order_load($order_id);
          }
        }
        break;
      case 'subscr_failed':
        // Calculate when the next retry will be and then extend.

        // 
        return;
      case 'subscr_eot':
      case 'subscr_cancel':
        $fees = uc_recurring_get_fees($order);
        if ($fee = $fees[0]) {
          uc_recurring_fee_cancel($fee->rfid, $fee);
        }
        $txn_id = $subscr_id;
        break;
    }

    $duplicate = db_result(db_query("SELECT COUNT(*) FROM {uc_payment_paypal_ipn} WHERE txn_id = '%s' AND txn_type = '%s' AND status <> 'Pending'", $txn_id, $txn_type));
    if ($duplicate > 0) {
      if ($order->payment_method != 'credit') {
        watchdog('uc_recurring_hosted', 'IPN transaction ID has been processed before.', array(), WATCHDOG_NOTICE);
      }
      return;
    }

    db_query("INSERT INTO {uc_payment_paypal_ipn} (order_id, txn_id, txn_type, mc_gross, status, receiver_email, payer_email, received) VALUES (%d, '%s', '%s', '%s', '%s', '%s', '%s', %d)",
      $order_id, $txn_id, $txn_type, $payment_amount, $payment_status, $receiver_email, $payer_email, time());

    $context = array(
      'revision' => 'formatted-original',
      'type' => 'amount',
    );
    $options = array(
      'sign' => FALSE,
    );

    switch ($payment_status) {
      case 'Canceled_Reversal':
        uc_order_comment_save($order_id, 0, t('PayPal has cancelled the reversal and returned !amount !currency to your account.', array('!amount' => uc_price($payment_amount, $context, $options), '!currency' => $payment_currency)), 'admin');
        break;

      case 'Completed':
        $comment = t('PayPal transaction ID: @txn_id', array('@txn_id' => $txn_id));
        uc_payment_enter($order_id, 'paypal_wps', $payment_amount, $order->uid, NULL, $comment);
        uc_cart_complete_sale($order);
        uc_order_comment_save($order_id, 0, t('Payment of @amount @currency submitted through PayPal.', array('@amount' => uc_price($payment_amount, $context, $options), '@currency' => $payment_currency)), 'order', 'payment_received');
        uc_order_comment_save($order_id, 0, t('PayPal IPN reported a payment of @amount @currency.', array('@amount' => uc_price($payment_amount, $context, $options), '@currency' => $payment_currency)));
        break;

      case 'Denied':
        uc_order_comment_save($order_id, 0, t("You have denied the customer's payment."), 'admin');
        break;

      case 'Expired':
        uc_order_comment_save($order_id, 0, t('The authorization has failed and cannot be captured.'), 'admin');
        break;

      case 'Failed':
        uc_order_comment_save($order_id, 0, t("The customer's attempted payment from a bank account failed."), 'admin');
        break;

      case 'Pending':
        uc_order_update_status($order_id, 'paypal_pending');
        uc_order_comment_save($order_id, 0, t('Payment is pending at PayPal: @reason', array('@reason' => _uc_paypal_pending_message(check_plain($_POST['pending_reason'])))), 'admin');
        break;

      // You, the merchant, refunded the payment.
      case 'Refunded':
        $comment = t('PayPal transaction ID: @txn_id', array('@txn_id' => $txn_id));
        uc_payment_enter($order_id, 'paypal_wps', $payment_amount, $order->uid, NULL, $comment);
        break;

      case 'Reversed':
        watchdog('uc_recurring_hosted', 'PayPal has reversed a payment!', array(), WATCHDOG_ERROR);
        uc_order_comment_save($order_id, 0, t('Payment has been reversed by PayPal: @reason', array('@reason' => _uc_paypal_reversal_message(check_plain($_POST['reason_code'])))), 'admin');
        break;

      case 'Processed':
        uc_order_comment_save($order_id, 0, t('A payment has been accepted.'), 'admin');
        break;

      case 'Voided':
        uc_order_comment_save($order_id, 0, t('The authorization has been voided.'), 'admin');
        break;
    }
  }
  elseif (strcmp($response->data, 'INVALID') == 0) {
    watchdog('uc_recurring_hosted', 'IPN transaction failed verification.', array(), WATCHDOG_ERROR);
    uc_order_comment_save($order_id, 0, t('An IPN transaction failed verification for this order.'), 'admin');
  }
}

/**
 * Display info on canceling the Paypal WPS subscription.
 */
function uc_recurring_hosted_paypal_cancel_form($form_state, $rfid) {
  $output = t('You can cancel your subscription from your paypal account, see <a href="@link">here</a> for instructions.', array('@link' => 'https://www.paypal.com/helpcenter/main.jsp?cmd=_help&t=solutionTab&solutionId=11750'));
  return $output;
}

/**
 * Mock page for testing the Paypal verifry call.
 */
function _uc_recurring_hosted_paypal_mock_web_page() {
  echo 'VERIFIED';
  exit();
}
