<?php
// $Id$

/**
 * @file
 * Allows you to add a recurring fee to a product/SKU to handle subscription
 *   type services.
 *
 * This module includes code for the recurring fee product feature and a default
 * recurring fee handler.  The default handler simply adds fees to the queue to
 * be processed on cron runs.  Initial charges, even if they're set to occur in
 * 0 days will not be processed immediately upon checkout
 */


/*******************************************************************************
 * Drupal Hooks
 ******************************************************************************/

/**
 * Implementation of hook_menu().
 */
function uc_recurring_menu() {
  $items = array();

  $items['admin/store/orders/recurring'] = array(
    'title' => 'Recurring fees',
    'description' => 'View the recurring fees on your orders.',
    'page callback' => 'uc_recurring_admin',
    'access arguments' => array('administer recurring fees'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 5,
    'file' => 'uc_recurring.admin.inc',
  );
  $items['user/%user/recurring-fees'] = array(
    'title' => 'Recurring fees',
    'description' => 'View current recurring fees.',
    'page callback' => 'uc_recurring_user_fees',
    'page arguments' => array(1),
    'access callback' => 'uc_recurring_user_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  $items['user/%user/recurring/%/cancel'] = array(
    'title' => 'Cancel the recurring fee?',
    'description' => 'Cancel a recurring fee.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_recurring_user_cancel_form', 1, 3),
    'access callback' => 'uc_recurring_user_access',
    'access arguments' => array(1, 3),
    'type' => MENU_CALLBACK,
    'file' => 'uc_recurring.pages.inc',
  );
  $items['admin/store/orders/recurring/view/fee/%'] = array(
    'title' => 'Recurring fees',
    'description' => 'View a specific recurring fee.',
    'page callback' => 'uc_recurring_admin',
    'access arguments' => array('administer recurring fees'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 5,
    'file' => 'uc_recurring.admin.inc',
  );
  $items['admin/store/orders/recurring/view/order/%'] = array(
    'title' => 'Recurring fees',
    'description' => 'View the recurring fees on a specific order.',
    'page callback' => 'uc_recurring_admin',
    'access arguments' => array('administer recurring fees'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 5,
    'file' => 'uc_recurring.admin.inc',
  );
  $items['admin/store/orders/recurring/%/charge'] = array(
    'title' => 'Charge recurring fee @fee?',
    'title arguments' => array('@fee' => 4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_recurring_admin_charge_form', 4),
    'access arguments' => array('administer recurring fees'),
    'type' => MENU_CALLBACK,
    'file' => 'uc_recurring.admin.inc',
  );
  $items['admin/store/orders/recurring/%/edit'] = array(
    'title' => 'Edit recurring fee @fee',
    'title arguments' => array('@fee' => 4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_recurring_admin_edit_form'),
    'access arguments' => array('administer recurring fees'),
    'type' => MENU_CALLBACK,
    'file' => 'uc_recurring.admin.inc',
  );
  $items['admin/store/orders/recurring/%/delete'] = array(
    'title' => 'Delete recurring fee @fee?',
    'title arguments' => array('@fee' => 4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_recurring_admin_delete_form'),
    'access arguments' => array('administer recurring fees'),
    'type' => MENU_CALLBACK,
    'file' => 'uc_recurring.admin.inc',
  );

  return $items;
}

/**
 * Restrict access to recurring fee operations for users.
 *
 * @param $account
 *   The user account being accessed
 * @param $rfid
 *   The id of the recurring fee being access, parsing NULL checks 
 *     if we can access any recurring fees for the account  
 * @return 
 *   True if user has permission to access account
 */
function uc_recurring_user_access($account, $rfid = NULL) {
  global $user;

  // Let administrators do whatever they want.
  if (user_access('administer recurring fees')) {
    return TRUE;
  }

  // return false if there are no recurring fees
  $result = db_result(db_query("SELECT count(*) FROM {uc_recurring_users} WHERE uid = %d AND (remaining_intervals > 0 OR remaining_intervals IS NULL)", $account->uid));
  if ($result == 0) {
    return FALSE;
  }

  if ($rfid == NULL) {
    if (user_access('view own recurring fees') && $user->uid == $account->uid) {
      return TRUE;
    }
  } 
  else {
    // Users can only access forms for their own recurring fees through their own
    // user account.
    $fee_uid = db_result(db_query("SELECT uid FROM {uc_recurring_users} WHERE rfid = %d", $rfid));

    if (user_access('view own recurring fees') && $user->uid == $account->uid && $account->uid == $fee_uid) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Implementation of hook_perm().
 */
function uc_recurring_perm() {
  return array('administer recurring fees', 'view own recurring fees');
}

/**
 * Implementation of hook_form_alter().
 */
function uc_recurring_form_alter(&$form, &$form_state, $form_id) {
  // We may need to alter the checkout form to remove invalid payment methods.
  if ($form_id == 'uc_cart_checkout_form' && isset($form['panes']['payment'])) {
    $order = new stdClass();
    $order->products = uc_cart_get_contents();

    // Make no changes if no recurring fees are found.
    if (uc_recurring_find_fees($order) == array()) {
      return;
    }

    // If configured, display a message about the recurring fees.
    if ($message = variable_get('uc_recurring_checkout_message', '')) {
      drupal_set_message(check_markup($message));
    }

    // Remove invalid payment methods from the payment pane.
    $valid = variable_get('uc_recurring_payment_methods', array());
    foreach (array_keys($form['panes']['payment']['payment_method']['#options']) as $key) {
      if (!isset($valid[$key]) || $valid[$key] === 0) {
        unset($form['panes']['payment']['payment_method']['#options'][$key]);
      }
    }

    $count = count($form['panes']['payment']['payment_method']['#options']);
    if ($count == 0) {
      // Display an error message if no payment methods remain.
      drupal_set_message(t('There are no payment methods configured for orders with recurring fees!'), 'error');
      drupal_set_message(t('Please contact an administrator to solve the issue.'), 'error');
    }
    elseif ($count == 1) {
      // If only one payment method remains, make it the default.
      $form['panes']['payment']['payment_method']['#default_value'] = array_pop(array_keys($form['panes']['payment']['payment_method']['#options']));
    }
  }

  // Wipe any existing recurring fees on the review form load to prevent
  // duplicate or unexpected fees.
  if ($form_id == 'uc_cart_checkout_review_form') {
    db_query("DELETE FROM {uc_recurring_users} WHERE order_id = %d", $_SESSION['cart_order']);
  }

  if ($form_id == 'uc_order_view_update_form') {
    // Load the order object based on the form value for the order ID.
    $order = uc_order_load($form['order_id']['#value']);

    // Load up the valid payment methods.
    $methods = variable_get('uc_recurring_payment_methods', array());

    // Check to make sure the payment method is good and we're in CC debug mode.
    if ($methods[$order->payment_method] === $order->payment_method && variable_get('uc_credit_debug', FALSE)) {
      // Look for recurring fees on this order.
      $fees = uc_recurring_find_fees($order);

      // If we have fees, check to see if they've already been added to the order.
      if (count($fees)) {
        $result = db_result(db_query("SELECT COUNT(*) FROM {uc_recurring_users} WHERE order_id = %d", $order->order_id));

        // If they haven't been added, display the checkbox to make it so.
        if ($result < count($fees)) {
          $form['process_fees'] = array(
            '#type' => 'checkbox',
            '#title' => t('Process the recurring fees associated with products on this order.', array('@count' => count($fees))),
            '#description' => t('This action will not be available after any fees are successfully processed.<br /><b>Important:</b> You must verify that the credit card information is correct before processing the fees!'),
            '#weight' => 5,
          );
          $form['#submit'][] = 'uc_recurring_order_view_update_form_submit';
        }
      }
    }
  }
}

/**
 * TODO: Investigate the use/need for this function - the only way to setup a recurring payment after 
 * inital processing is if you have the clients payment details - which for most gateways you wont.
 *
 * Submit function for the order view update form to process recurring fees.
 */
function uc_recurring_order_view_update_form_submit($form, &$form_state) {
  if ($form_state['values']['process_fees']) {
    $order = uc_order_load($form_state['values']['order_id']);
    $fees = uc_recurring_find_fees($order);

    if (count($fees)) {
      $pass = TRUE;
      foreach ($fees as $fee) {
        if (!uc_recurring_process($order, $fee)) {
          uc_order_comment_save($order->order_id, 0, t('The recurring fee for product @model failed.', array('@model' => $fee->model)), 'admin', $order->order_status);
          $pass = FALSE;
        }
      }
      if ($pass == FALSE) {
        drupal_set_message(t('One or more recurring fees failed to process as indicated in the admin comments.'), 'error');
      }
    }
  }
}

/**
 * Implementation of hook_cron().
 *
 * On the renewal datetime of a recurring fee see if the payment method would like to perfom any addition actions
 *
 * TODO: limit the number of recurring orders to process on each cron job (maybe 
 * this can be done based on time, incase a remote server is slow a responding to
 * requests)
 */
function uc_recurring_cron() {
  $successes = 0;
  $fails = 0;

  $result = db_query("SELECT * FROM {uc_recurring_users} WHERE (remaining_intervals > 0 OR remaining_intervals IS NULL) AND next_charge <= %d", time());
  while ($fee = db_fetch_array($result)) {
    $fee['data'] = unserialize($fee['data']);

    $order_id = uc_recurring_renew($fee);
    if ($order_id) {
      $successes++;
      // update the status which will invoke any hooks that respond to completed status
      uc_order_update_status($order_id, 'completed');
    } 
    else {
      // payment attempted but failed
      $fails--;
    }
  }

  if ($successes > 0 || $fails > 0) {
    watchdog('uc_recurring', '!successes recurring fees processed successfully; !fails failed.', array('!successes' => $successes, '!fails' => $fails));
  }
}

/**
 * Attempts to find a recurring fee with some specific data/id stored by the fee_handler
 */
function uc_recurring_find_fee($fee_handler, $data) {
  $fee = db_fetch_array(db_query("SELECT * FROM {uc_recurring_users} WHERE fee_handler = '%s' AND data LIKE '%%s%'", $fee_handler, $data));
  if (!empty($fee)) {
    $fee['data'] = unserialize($fee['data']);
    return $fee;
  }
  return FALSE;
}

/**
 * Process a renewal, either from the cron job or manually from a fee_handler 
 *
 * @param $fee
 *   array of the fee object to be renewed  
 * @param $check_handler
 *   set this FALSE if the recurring payment does not need to check the fee_handler, 
 *   it means the payment method/gateway needs to handle the actually payment recording 
 *   itself, this is useful for gateways like Paypal's IPN.
 * @return 
 *   (int)order_id of the new order or FALSE if unable to renew fee
 */
function uc_recurring_renew($fee, $check_handler = TRUE) {
  // attempt to a call uc_recurring_[fee_handler]_renew() function if it exits
  $renew_func = 'uc_recurring_'. $fee['fee_handler'] .'_renew'; 
  if ($check_handler == FALSE || function_exists($renew_func)) {
    // Load the order.
    $order = uc_order_load($fee['order_id']);

    $fee_amount = $fee['fee_amount'];

    // create a new order by cloning the currenting order and replacing order id's
    $new_order = uc_order_new($order->uid, 'in_checkout');
    $old_id = $fee['order_id'];
    $new_id = $new_order->order_id;
    $new_order = $order;
    $new_order->order_id = $new_id;
    $fee['order_id'] = $new_id;
    $fee['attempts']++;

    unset($new_order->products);
    // add recurring fee item to the order
    $product = new stdClass();
    $product->order_id = $new_id;
    $product->nid = $fee['data']['nid'];
    $product->model = $fee['data']['model'];
    $product->title = $fee['fee_title'] == '' ? 'renewal' : $fee['fee_title'];
    $product->qty = 1;
    $product->price = $fee_amount;
    $product->data = $fee['data']['product']->data;

    $new_order->products[] = $product;

    // lets give other modules a chance to modify the new order
    module_invoke_all('recurring_renew', $new_order, $fee);

    // calculate the new fee amount to charge on this order 
    $fee['fee_amount'] = uc_order_get_total($new_order);
    uc_order_update_status($new_id, 'processing');

    if ($check_handler == FALSE || ($check_handler && $renew_func($new_order, $fee))) {
      uc_order_update_status($new_id, 'payment_received');
      // payment was successful save the new order
      uc_order_save($new_order);
  
      uc_order_comment_save($new_id, 0, t('!amount recurring fee collected. (ID: <a href="!url">!fee</a>)', array('!url' => url('admin/store/orders/recurring/view/fee/'. $fee['rfid']), '!fee' => $fee['rfid'], '!amount' => uc_currency_format($fee['fee_amount']))));
 
      // also add a comment in the old order history to refer to the recurring fee and order
      uc_order_comment_save($old_id, 0, t('New recurring fee processed, new order is <a href="!url">!order_id</a>.', array('!url' => url('admin/store/orders/'.$new_id), '!order_id' => $new_id)));

      if ($fee['remaining_intervals'] > 0) $fee['remaining_intervals'] -= 1;

      // Update the fee in the database.
      if ($fee['remaining_intervals'] !== NULL && $fee['remaining_intervals'] == 0) {
        $next_charge = time();
  
        // TODO: should we provide any hooks/CA here?
        // e.g. allow a module to remind people their subscription has ended
      }
      else {
        $next_charge = strtotime('+'. $fee['regular_interval']);
        $user_fee = array(
          'rfid' => 0,
          'uid' => $new_order->uid,
          'fee_handler' => $fee['fee_handler'],
          'fee_title' => $fee['fee_title'],
          'next_charge' => $next_charge,
          'fee_amount' => $fee_amount,
          'regular_interval' => $fee['regular_interval'],
          'remaining_intervals' => $fee['remaining_intervals'],
          'charged_intervals' => $fee['charged_intervals']+1,
          'order_id' => $new_id,
          'data' => serialize($fee['data']),
          'pfid' => $fee['pfid'],
          'attempts' => 0,
        );
        $user_fee['rfid'] = uc_recurring_fee_save('user', $user_fee);

        uc_order_comment_save($new_id, 0, t('New recurring fee created for next renewal. (<a href="!url">click here to see when due</a>)', array('!url' => url('admin/store/orders/recurring/view/fee/'. $user_fee['rfid']), '!fee' => $user_fee['rfid'])));
      }
  
      // stop the old recurring payment
      db_query("UPDATE {uc_recurring_users} 
                SET next_charge = %d, 
                    remaining_intervals = 0, 
                    charged_intervals = charged_intervals + 1,
                    attempts = %d 
                WHERE rfid = %d", time(), $fee['attempts'], $fee['rfid']);
  
      // TODO: should this just be part of conditional actions?
      // Modules can hook into the charge process using hook_recurring_api().
      module_invoke_all('recurring_api', 'charge', $fee);
  
      return $new_id;
    }
    else {
      uc_order_comment_save($fee['order_id'], 0, t('Error: Recurring fee <a href="!url">!fee</a> for product @model failed.', array('!url' => url('admin/store/orders/recurring/view/fee/'. $fee['rfid']), '!fee' => $fee['rfid'], '@model' => $fee['data']['model'])));
      watchdog('uc_recurring', 'Failed to capture recurring fee of !amount for product @model on order !order_id.', array('!amount' => $fee['fee_amount'], '@model' => $fee['data']['model'], '!order_id' => $fee['order_id']), WATCHDOG_ERROR, l(t('order !order_id', array('!order_id' => $fee['order_id'])), 'admin/store/orders/'. $fee['order_id']));
  
      // TODO: should this just be part of conditional actions?
      // Modules can hook into the charge process using hook_recurring_api().
      module_invoke_all('recurring_api', 'fail', $fee);
  
      // TODO: what can we do to better handle failures?
      // ie: 
      //    notify user/admin
      //    extend current order for set time to give user a chance to fix problem

      // handle extensions
      $result = db_query("SELECT * FROM {uc_recurring_extensions} WHERE rebill_attempt = %d AND (pfid IS NULL OR pfid = %d) ORDER BY pfid DESC", $fee['attempts'], $fee['pfid']);
      $extend_seconds = 0;
      if ($result == FALSE) {
        // no more extensions
      }
      else {
        $extension = db_fetch_array($result);
        $extend_seconds = $extension['time_to_extend'];
        if ($extend_seconds) {
           // TODO: we probably want to trigger an email message to user
        }
      }

      $ext = $fee['next_charge'] + $extend_seconds;
      db_query("UPDATE {uc_recurring_users} 
                SET attempts = %d, 
                  next_charge = %d 
                WHERE rfid = %d", $fee['attempts'], $ext, $fee['rfid']);
    }
  }
  return FALSE;
}

/**
 * Implementation of hook_user().
 */
function uc_recurring_user($op, &$edit, &$account, $category = NULL) {
  global $user;
  switch ($op) {
    case 'view':
      if ($user->uid && (($user->uid == $account->uid && user_access('view own recurring fees') && uc_recurring_user_access($account)) || user_access('administor recurring fees'))) {
        $account->content['recurring_fees'] = array(
          '#type' => 'user_profile_category',
          '#weight' => -3,
          '#title' => t('Recurring fees'),
          'table' => array(
            '#type' => 'user_profile_item',
            '#value' => l('Click here to view your recurring fees', 'user/'. $user->uid . '/recurring-fees'),
          ),
        );
      }

      break;
  }
}

/**
 * Display users recurrings fees
 */
function uc_recurring_user_fees($user) {
  return theme('uc_recurring_user_table', $user->uid);
}

/*******************************************************************************
 * Ubercart Hooks
 ******************************************************************************/

/**
 * Implementation of hook_order().
 */
function uc_recurring_order($op, &$arg1, $arg2) {
  switch ($op) {
    case 'submit':
      if (variable_get('uc_recurring_checkout_process', TRUE)) {
        $fees = uc_recurring_find_fees($arg1);
        if (count($fees)) {
          $pass = TRUE;
          foreach ($fees as $fee) {
            if (!uc_recurring_process($arg1, $fee)) {
              uc_order_comment_save($arg1->order_id, 0, t('The recurring fee for product @model failed.', array('@model' => $fee->model)), 'admin', $arg1->order_status);
              $pass = FALSE;
            }
          }
          if ($pass == FALSE) {
            $process = variable_get('uc_recurring_checkout_fail', 'fail');
            if ($process == 'fail' && uc_payment_balance($arg1) < $arg1->order_total) {
              $process = 'proceed';
            }
            switch ($process) {
              case 'fail':
                return array(array('pass' => FALSE, 'message' => t('Your order cannot be completed, because we could not process your recurring payment. Please review your payment details and contact us to complete your order if the problem persists.')));
              case 'proceed':
                return array(array('pass' => TRUE, 'message' => t('Your order has been submitted, but we may need to contact you to ensure your recurring fee is set up properly. Thank you for your understanding.')));
            }
          }
        }
      }
      break;

    case 'update':
      if (uc_order_status_data($arg1->order_status, 'state') == 'in_checkout') {
        db_query("UPDATE {uc_recurring_users} SET uid = %d WHERE uid = 0 AND order_id = %d", $arg1->uid, $arg1->order_id);
      }
  }
}

/**
 * Implementation of hook_product_feature().
 */
function uc_recurring_product_feature() {
  $features[] = array(
    'id' => 'recurring',
    'title' => t('Recurring fee'),
    'callback' => 'uc_recurring_feature_form',
    'delete' => 'uc_recurring_fee_delete',
    'settings' => 'uc_recurring_settings_form',
  );

  return $features;
}

/**
 * Implementation of hook_recurring_fee_ops().
 */
function uc_recurring_recurring_fee_ops($context, $fee) {
  $ops = array();

  switch ($context) {
    case 'fee_admin':
      if ($fee['remaining_intervals'] > 0 || $fee['remaining_intervals'] === NULL) {
        $ops[] = l(t('charge'), 'admin/store/orders/recurring/'. $fee['rfid'] .'/charge');
      }
      $ops[] = l(t('edit'), 'admin/store/orders/recurring/'. $fee['rfid'] .'/edit');
      $ops[] = l(t('delete'), 'admin/store/orders/recurring/'. $fee['rfid'] .'/delete');
      break;

    case 'user':
      $ops[] = l(t('cancel'), 'user/'. $fee['uid'] .'/recurring/'. $fee['rfid'] .'/cancel');
  }

  return $ops;
}


/******************************************************************************
 * Workflow-ng Hooks                                                          *
 ******************************************************************************/

// Tell Workflow about the various order events.
function uc_recurring_event_info() {
  $events['fee_expires'] = array(
    '#label' => t('Recurring payment expires'),
    '#module' => t('Recurring Payments'),
    '#arguments' => array(
      'order' => array('#entity' => 'order', '#label' => t('Order')),
    ),
  );
  $events['fee_charge_successful'] = array(
    '#label' => t('Payment is charged successfully'),
    '#module' => t('Recurring Payments'),
    '#arguments' => array(
      'order' => array('#entity' => 'order', '#label' => t('Order')),
    ),
  );
  $events['fee_charge_fails'] = array(
    '#label' => t('Payment charge fails'),
    '#module' => t('Recurring Payments'),
    '#arguments' => array(
      'order' => array('#entity' => 'order', '#label' => t('Order')),
    ),
  );

  return $events;
}


/*******************************************************************************
 * Callback Functions
 ******************************************************************************/

// Builds the form to display for adding or editing a recurring fee.
function uc_recurring_feature_form($form_state, $node, $feature) {
  drupal_add_css(drupal_get_path('module', 'uc_recurring') .'/uc_recurring.css');

  if (!empty($feature)) {
    $fee = uc_recurring_fee_load('product', $feature['pfid']);
  }

  $options = uc_product_get_models($node);

  $form['model'] = array(
    '#type' => 'select',
    '#title' => t('Applicable SKU'),
    '#description' => t('Select the applicable product model/SKU for this fee.'),
    '#options' => $options,
    '#default_value' => $fee['model'],
  );

  $form['fee'] = array(
    '#type' => 'fieldset',
    '#title' => t('Recurring Fee Amount'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the amount that is charged on each renewal date.'),
  );

  $attributes = array('onclick' => 'if ( $("#edit-fee-same-product").attr("checked") ) { $("#edit-fee-amount").attr("disabled","disabled"); $("#edit-fee-amount").val($("#edit-product-price").val()); } else { $("#edit-fee-amount").removeAttr("disabled"); }');
  if ($fee['fee_amount'] == -1) {
    $attributes['checked'] = 'checked';
  }
  $form['fee']['fee_same_product'] = array(
    '#type' => 'checkbox',
    '#title' => t('Set the recurring fee amount to the same as selling price of the product at the time of purchase.'),
    '#attributes' => $attributes,
  );

  $form['fee']['product_price'] = array(
    '#type' => 'hidden',
    '#value' => $node->sell_price,
  );
  $form['fee']['fee_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Recurring fee amount'),
    '#description' => t('Charge this amount each billing period.<br />The product price is still charged at checkout.'),
    '#default_value' => $fee['fee_amount'] == -1 ? $node->sell_price : $fee['fee_amount'],
    '#size' => 16,
    '#field_prefix' => variable_get('uc_sign_after_amount', FALSE) ? '' : variable_get('uc_currency_sign', '$'),
    '#field_suffix' => variable_get('uc_sign_after_amount', FALSE) ? variable_get('uc_currency_sign', '$') : '',
    '#attributes' => ($fee['fee_amount'] == -1 ? array('disabled' => 'disabled') : array()),
  );

  $form['interval'] = array(
    '#type' => 'fieldset',
    '#title' => t('Payment Interval Settings'),
    '#collapsible' => FALSE,
    '#description' => t('Remember the product price will be charged at the time of checkout. This section specifies when the recurring amount will be charged.'),
  );
  $form['interval']['initial'] = array(
    '#type' => 'fieldset',
    '#title' => t('Initial charge'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the time to wait to start charging the recurring fee after checkout.'),
    '#attributes' => array('class' => 'interval-fieldset'),
  );
  $form['interval']['initial']['initial_charge_value'] = array(
    '#type' => 'select',
    '#options' => drupal_map_assoc(uc_range(0, 52)),
    '#default_value' => $fee['initial_charge_value'],
  );
  $form['interval']['initial']['initial_charge_unit'] = array(
    '#type' => 'select',
    '#options' => array(
      'days' => t('day(s)'),
      'weeks' => t('week(s)'),
      'months' => t('month(s)'),
      'years' => t('year(s)'),
    ),
    '#default_value' => $fee['initial_charge_unit'],
  );

  $form['interval']['regular'] = array(
    '#type' => 'fieldset',
    '#title' => t('Regular interval'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the length of the billing period for this fee.'),
    '#attributes' => array('class' => 'interval-fieldset'),
  );
  $form['interval']['regular']['regular_interval_value'] = array(
    '#type' => 'select',
    '#options' => drupal_map_assoc(uc_range(1, 52)),
    '#default_value' => $fee['regular_interval_value'],
  );
  $form['interval']['regular']['regular_interval_unit'] = array(
    '#type' => 'select',
    '#options' => array(
      'days' => t('day(s)'),
      'weeks' => t('week(s)'),
      'months' => t('month(s)'),
      'years' => t('year(s)'),
    ),
    '#default_value' => $fee['regular_interval_unit'],
  );

  $form['num_interval'] = array(
    '#type' => 'fieldset',
    '#title' => t('Number of billing periods'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the time to wait to start charging the recurring fee after checkout.'),
  );

  $attributes = array('onclick' => 'if ( $("#edit-unlimited-intervals").attr("checked") ) { $("#edit-number-intervals").attr("disabled","disabled"); $("#edit-number-intervals").val(""); } else { $("#edit-number-intervals").removeAttr("disabled"); }');
  if ($fee['number_intervals'] == NULL) {
    $attributes['checked'] = 'checked';
  }
  $form['num_interval']['unlimited_intervals'] = array(
    '#type' => 'checkbox',
    '#title' => t('Unlimited rebillings.'),
    '#attributes' => $attributes,
  );
  $form['num_interval']['number_intervals'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of billing periods'),
    '#description' => t('Specify how many times the recurring fee will be charged.'),
    '#size' => 16,
    '#default_value' => $fee['number_intervals'] == NULL ? '' : $fee['number_intervals'],
    '#attributes' => ($fee['number_intervals'] == NULL ? array('disabled' => 'disabled') : array()),
  );

  return uc_product_feature_form($form);
}

function uc_recurring_feature_form_validate($form, &$form_state) {
  if ($form_state['values']['unlimited_intervals'] != 1 && intval($form_state['values']['number_intervals']) <= 0) {
    form_set_error('number_intervals', t('Only positive whole number values are accepted for the number of billing periods.'));
  }
}

function uc_recurring_feature_form_submit($form, &$form_state) {
  // Use the form specified pfid if available.
  if (!empty($form_state['values']['pfid'])) {
    $pfid = $form_state['values']['pfid'];
  }

  // we store an amount of -1 if we are setting the recurring fee equal to product price
  if ($form_state['values']['fee_same_product']) {
    $form_state['values']['fee_amount'] = -1;
  }

  // we set the number_intervals to NULL if unlimited
  if ($form_state['values']['unlimited_intervals']) {
    $form_state['values']['number_intervals'] = 'NULL';
  }
  else {
    $form_state['values']['number_intervals'] = intval($form_state['values']['number_intervals']);
  }

  // Build the recurring fee's data array.
  $fee = array(
    'pfid' => $pfid,
    'model' => $form_state['values']['model'],
    'fee_amount' => $form_state['values']['fee_amount'],
    'initial_charge' => $form_state['values']['initial_charge_value'] .' '. $form_state['values']['initial_charge_unit'],
    'regular_interval' => $form_state['values']['regular_interval_value'] .' '. $form_state['values']['regular_interval_unit'],
    'number_intervals' => $form_state['values']['number_intervals'],
  );

  $context = array(
    'revision' => 'formatted-original',
    'location' => 'recurring-feature-submit',
  );

  $args = array(
    '@product' => empty($fee['model']) ? t('this product') : t('product @model', array('@model' => $fee['model'])),
    '!amount' => $form_state['values']['fee_amount'] == -1 ? 'the same amount as the product selling price' : uc_price($fee['fee_amount'], $context),
    '!initial' => $fee['initial_charge'],
    '!regular' => $fee['regular_interval'],
    '!intervals' => t('!num times', array('!num' => ($fee['number_intervals'] == 'NULL' ? 'Unlimited' : ($fee['number_intervals'] - 1)))),
  );

  // Build the feature's data array.
  $data = array(
    'pfid' => $pfid,
    'nid' => $form_state['values']['nid'],
    'fid' => 'recurring',
    'description' => t('When @product is purchased, add a fee for !amount charged first after !initial and every !regular after that !intervals.', $args),
  );

  // Save the product feature and store the returned URL as our redirect.
  $form_state['redirect'] = uc_product_feature_save($data);

  if (empty($pfid)) {
    $fee['pfid'] = db_last_insert_id('uc_product_features', 'pfid');
  }

  uc_recurring_fee_save('product', $fee);
}

// Adds the settings for the recurring module on the feature settings form.
function uc_recurring_settings_form() {
  foreach (_payment_method_list() as $method) {
    if (function_exists('uc_recurring_'. $method['id'] .'_fee')) {
      $options[$method['id']] = $method['name'];
    }
  }
  $form['uc_recurring_payment_methods'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Valid payment methods for orders with recurring fees'),
    '#description' => t('Only selected payment methods will be available for customers purchasing products with recurring fees.<br/>It is up to you to make sure your chosen handler is compatible with the payment methods you select.<br />For example, the uc_recurring handler is only compatible with the Credit Card payment method.'),
    '#options' => $options,
    '#default_value' => variable_get('uc_recurring_payment_methods', array()),
  );
  $form['uc_recurring_checkout_message'] = array(
    '#type' => 'textarea',
    '#title' => t('Recurring fee checkout form message'),
    '#description' => t('Enter a message to be displayed on the checkout form page when a customer has products in the cart with recurring fees.<br />Leave blank to not display any message.'),
    '#default_value' => variable_get('uc_recurring_checkout_message', ''),
  );
  $form['uc_recurring_checkout_process'] = array(
    '#type' => 'checkbox',
    '#title' => t('Attempt to process recurring fees during checkout.'),
    '#description' => t('If not selected, you must have an alternate way of processing fees.<br />With the default handler, this is only possible in credit card debug mode.'),
    '#default_value' => variable_get('uc_recurring_checkout_process', TRUE),
  );
  $form['uc_recurring_checkout_fail'] = array(
    '#type' => 'radios',
    '#title' => t('Action to take if a recurring fee fails to process during checkout'),
    '#description' => t('Regardless of your selection, an admin comment will report the failure.<br/><strong>Note:</strong> Even if you select the first option, checkout will complete if another payment has already been captured.'),
    '#options' => array(
      'fail' => t('Return a failed message and do not complete checkout.'),
      'proceed' => t('Return a failed message but complete checkout.'),
      'silent' => t('Show no message and complete checkout.'),
    ),
    '#default_value' => variable_get('uc_recurring_checkout_fail', 'fail'),
  );
  /*
  TODO: feature request, prevent/warn users against purcahsing the same product while they have an active subscription
  $form['uc_recurring_duplicate_orders'] = array(
    '#type' => 'radios',
    '#title' => t('Action to take if a person attempts to renew/re-purchase a that they already have an active recurring fee.'),
    '#description' => t('Select how you want to handle users that attempt to renewing or purchase a subscription when they already have an active recurring fee.'),
    '#options' => array(
      'fail' => t('Prevent purchase.'),
      'proceed' => t('Warn user, but allow purchase.'),
      'silent' => t('Allow the purchase.'),
    ),
    '#default_value' => variable_get('uc_recurring_duplicate_orders', 'proceed'),
  );
  */

  $form['extensions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Extensions'),
    '#description' => t('Configure how many time and at what intervals to attempt rebilling on a failed recurring payment.'),
  );
  $result = db_query("SELECT * from {uc_recurring_extensions} WHERE pfid IS NULL ORDER BY rebill_attempt");
  while($ext = db_fetch_array($result)) {
    $rows[] = array(
      'attempt' => $ext['rebill_attempt'],
      'time_to_extent' => $ext['time_to_extend'] == 0 ? t('expire') : t('@num_days days', array('@num_days' => $ext['time_to_extend'] / (24*60*60))), 
    );
    if ($ext['time_to_extend'] == 0) break;
  }
  /*
  TODO: need to build forms to edit/update the extension settings
  $rows[] = array(
    'edit' => array(
      'data' => l(t('Edit default extention settings'), 'admin/settings/recurring/extensions'),
      'colspan' => 2
    )
  );
  */
  $form['extensions']['default'] = array(
    '#value' => theme('table', array('Attempt #', 'Time to extend'), $rows, array('style' => "width: auto;")) 
  );

  return $form;
}

/**
 * Implements hook_theme() 
 */
function uc_recurring_theme() {
  return array(
    'uc_recurring_user_table' => array(
      'arguments' => array($uid => NULL),
    ),
  );
}


// Displays a table for users to administer their recurring fees.
function theme_uc_recurring_user_table($uid) {
  $rows = array();
  $output = '';

  // Set up a header array for the table.
  $header = array(t('Order'), t('Amount'), t('Interval'), t('Next charge'), t('Remaining'), t('Operations'));

  $context = array(
    'revision' => 'themed-original',
    'location' => 'recurring-user-table',
  );

  // Loop through the fees sorted by the order ID descending.
  $result = db_query("SELECT * FROM {uc_recurring_users} WHERE uid = %d AND (remaining_intervals > 0 OR remaining_intervals IS NULL) ORDER BY order_id DESC", $uid);
  while ($fee = db_fetch_array($result)) {
    $ops = array();

    // Get the $ops from the module implementing the handler.
    $callback = 'uc_recurring_'. $fee['fee_handler'] .'_fee_ops';
    if (function_exists($callback)) {
      $ops = $callback('user', $fee);
    }

    // Add the row to the table for display.
    $rows[] = array(
      l($fee['order_id'], 'user/'. $uid .'/order/'. $fee['order_id']),
      uc_price($fee['fee_amount'], $context),
      array('data' => check_plain($fee['regular_interval']), 'nowrap' => 'nowrap'),
      format_date($fee['next_charge'], 'small'),
      $fee['remaining_intervals'] === NULL ? t('till cancelled') : $fee['remaining_intervals'],
      array('data' => implode(' ', $ops), 'nowrap' => 'nowrap'),
    );
  }

  // Only display the table if fees were found.
  if (count($rows) > 0) {
    $output = theme('table', $header, $rows);
  }

  return $output;
}

/**
 * Saves a recurring fee either for a product or for a user.
 *
 * @param $type
 *   String specifying whether the fee is being added to a product as a feature
 *     or attached to a user account; use 'product' or 'user'.
 * @param $data
 *   An array of data for the fee depending on $type.
 * @return
 *   No return for 'product' $type; the rfid of the saved fee for 'user' $type.
 */
function uc_recurring_fee_save($type, $data) {
  switch ($type) {
    case 'product':
      // First attempt to update an existing row.
      db_query("UPDATE {uc_recurring_products} SET model = '%s', fee_amount = %f, initial_charge = '%s', regular_interval = '%s', number_intervals = %s WHERE pfid = %d",
        $data['model'], $data['fee_amount'], $data['initial_charge'], $data['regular_interval'], $data['number_intervals'], $data['pfid']);

      // Otherwise insert this feature as a new row.
      if (db_affected_rows() == 0) {
        db_query("INSERT INTO {uc_recurring_products} (pfid, model, fee_amount, initial_charge, regular_interval, number_intervals) VALUES (%d, '%s', %f, '%s', '%s', %s)",
          $data['pfid'], $data['model'], $data['fee_amount'], $data['initial_charge'], $data['regular_interval'], $data['number_intervals']);
      }
      break;

    case 'user':
      if ($data['remaining_intervals'] === NULL) {
        $data['remaining_intervals'] = 'NULL';
      }
      else {
        $data['remaining_intervals'] = intval($data['remaining_intervals']);
      }
      // First attempt to update an existing row.
      db_query("UPDATE {uc_recurring_users} SET uid = %d, fee_handler = '%s', fee_title = '%s', next_charge = %d, fee_amount = %f, regular_interval = '%s', remaining_intervals = %s, charged_intervals = %d, order_id = %d, data = '%s', pfid = %d, attempts = %d WHERE rfid = %d",
        $data['uid'], $data['fee_handler'], $data['fee_title'], $data['next_charge'], $data['fee_amount'], $data['regular_interval'], $data['remaining_intervals'], $data['charged_intervals'], $data['order_id'], $data['data'], $data['pfid'], $data['attempts'], $data['rfid']);

      // Otherwise insert this feature as a new row.
      if (db_affected_rows() == 0) {
        db_query("INSERT INTO {uc_recurring_users} (uid, fee_handler, fee_title, next_charge, fee_amount, regular_interval, remaining_intervals, charged_intervals, order_id, data, created, pfid, attempts) VALUES (%d, '%s', '%s', %d, %f, '%s', %s, %d, %d, '%s', %d, %d, %d)",
          $data['uid'], $data['fee_handler'], $data['fee_title'], $data['next_charge'], $data['fee_amount'], $data['regular_interval'], $data['remaining_intervals'], $data['charged_intervals'], $data['order_id'], $data['data'], time(), $data['pfid'], $data['attempts']);
        $data['rfid'] = db_last_insert_id('uc_recurring_users', 'rfid');
      }

      return $data['rfid'];
  }
}

/**
 * Loads a recurring fee either from a product or for a user.
 *
 * @param $type
 *   'product' to load a recurring fee product feature.
 *   'user' to load a recurring fee schedule for a user.
 * @param $id
 *   The ID of the fee to load, either the product feature ID or the recurring
 *     fee ID from the appropriate table.
 * @return
 *   An associative array of data for the specified fee.
 */
function uc_recurring_fee_load($type, $id) {
  switch ($type) {
    case 'product':
      $fee = db_fetch_array(db_query("SELECT * FROM {uc_recurring_products} WHERE pfid = %d", $id));
      if (!empty($fee)) {
        list($fee['initial_charge_value'], $fee['initial_charge_unit']) = explode(' ', $fee['initial_charge']);
        list($fee['regular_interval_value'], $fee['regular_interval_unit']) = explode(' ', $fee['regular_interval']);
      }
      break;
    case 'user':
      $fee = db_fetch_array(db_query("SELECT * FROM {uc_recurring_users} WHERE rfid = %d", $id));

      if ($fee['fee_handler'] == 'uc_recurring') {
        $fee['data'] = unserialize($fee['data']);

        if ($key = uc_credit_encryption_key()) {
          $crypt = new uc_encryption_class;
          $fee['data']['payment_details']['cc_number'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_number']);
          if (variable_get('uc_credit_debug', FALSE)) {
            $fee['data']['payment_details']['cc_cvv'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_cvv']);
          }
          $fee['data']['payment_details']['cc_exp_month'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_exp_month']);
          $fee['data']['payment_details']['cc_exp_year'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_exp_year']);
          uc_store_encryption_errors($crypt, 'uc_recurring');
        }
      }
      break;
  }

  return $fee;
}

/**
 * Deletes a recurring fee from a product or user.
 *
 * @param $type
 *   Either 'product' or 'user' to specify what type of delete needs to happen.
 * @param $id
 *   The ID of the recurring fee to be removed from the appropriate table.
 */
function uc_recurring_fee_delete($feature, $type = 'product') {
  switch ($type) {
    case 'product':
      db_query("DELETE FROM {uc_recurring_products} WHERE pfid = %d", $feature['pfid']);
      break;
    case 'user':
      module_invoke_all('recurring_api', 'delete', $feature['fid']);
      db_query("DELETE FROM {uc_recurring_users} WHERE rfid = %d", $feature['pfid']);
      break;
  }
}

/**
 * Cancels a user's recurring fee by setting remaining intervals to 0.
 *
 * @param $rfid
 *   The recurring fee's ID.
 */
function uc_recurring_fee_cancel($rfid) {
  db_query("UPDATE {uc_recurring_users} SET remaining_intervals = 0 WHERE rfid = %d", $rfid);
}

/**
 * Returns an array of recurring fees associated with any product on an order.
 *
 * @param $order
 *   The order object in question.
 * @return
 *   An array of recurring fee objects containing all their data from the DB.
 */
function uc_recurring_find_fees($order) {
  if (!is_array($order->products) || count($order->products) == 0) {
    return array();
  }

  $models = array();
  $nids = array();

  foreach ((array) $order->products as $product) {
    $nids[] = $product->nid;
    $models[] = check_plain($product->model);
  }

  $fees = array();
  $result = db_query("SELECT rp.*, pf.nid, n.title as fee_title
                      FROM {uc_recurring_products} AS rp 
                        LEFT JOIN {uc_product_features} AS pf ON rp.pfid = pf.pfid 
                        LEFT JOIN {node} AS n on n.nid = pf.nid 
                      WHERE rp.model IN ('". implode("', '", $models) ."') OR (rp.model = '' AND pf.nid IN ('". implode("', '", $nids) ."'))");
  while ($fee = db_fetch_object($result)) {
    foreach($order->products as $product) {
      if ($fee->nid == $product->nid) {
        $fee->product = $product;
        if ($fee->fee_amount == -1) {
          $fee->fee_amount = $product->price; 
        }
      }
    }
    $fees[] = $fee;
  }
  return $fees;
}

/**
 * Passes the information onto the specified fee handler for processing.
 *
 * @param $order
 *   The order object the fees are attached to.
 * @param $fee
 *   The fee object to be processed.
 * @return
 *   TRUE or FALSE indicating whether or not the processing was successful.
 */
function uc_recurring_process($order, $fee) {
  $handler = 'uc_recurring_'. $order->payment_method .'_fee';
  if (!function_exists($handler)) {
    drupal_set_message(t('A handler for processing recurring fees cannot be found.'), 'error');
    return FALSE;
  }

  if ($handler($order, $fee) == TRUE) {
    $fee->data['nid'] = $fee->nid;
    $fee->data['model'] = $fee->product->model;
    $fee->data['product'] = $fee->product;
    // successfully processed the setup of recurring fee
    $user_fee = array(
      'rfid' => 0,
      'uid' => $order->uid,
      'fee_handler' => $fee->fee_handler,
      'fee_title' => $fee->fee_title,
      'next_charge' => strtotime('+'. $fee->initial_charge),
      'fee_amount' => $fee->fee_amount,
      'regular_interval' => $fee->regular_interval,
      'remaining_intervals' => $fee->number_intervals,
      'charged_intervals' => 0,
      'order_id' => $order->order_id,
      'data' => serialize($fee->data),
      'pfid' => $fee->pfid,
      'attempts' => 0,
    );
  
    $user_fee['rfid'] = uc_recurring_fee_save('user', $user_fee);
  
    uc_order_comment_save($order->order_id, 0, t('Recurring fee <a href="!url">!fee</a> added to order.', array('!url' => url('admin/store/orders/recurring/view/fee/'. $user_fee['rfid']), '!fee' => $user_fee['rfid'])));
  
    return TRUE;
  }

  return FALSE;
}

